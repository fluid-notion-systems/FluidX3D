#!/usr/bin/env python3
"""
Generate a binary STL file of a sphere for testing FluidX3D bathymetry loading.
"""

import struct
import math

def generate_sphere_stl(filename, radius=5.0, center=(0, 0, 0), resolution=20):
    """
    Generate a binary STL file containing a sphere.

    Args:
        filename: Output STL filename
        radius: Sphere radius
        center: Sphere center (x, y, z)
        resolution: Number of subdivisions (higher = smoother sphere)
    """

    triangles = []

    # Generate sphere vertices using spherical coordinates
    for i in range(resolution):
        for j in range(resolution):
            # Current angles
            theta1 = (i / resolution) * math.pi  # 0 to pi
            phi1 = (j / resolution) * 2 * math.pi  # 0 to 2*pi

            # Next angles
            theta2 = ((i + 1) / resolution) * math.pi
            phi2 = ((j + 1) / resolution) * 2 * math.pi

            # Calculate vertices
            # Vertex 1
            x1 = center[0] + radius * math.sin(theta1) * math.cos(phi1)
            y1 = center[1] + radius * math.sin(theta1) * math.sin(phi1)
            z1 = center[2] + radius * math.cos(theta1)

            # Vertex 2
            x2 = center[0] + radius * math.sin(theta2) * math.cos(phi1)
            y2 = center[1] + radius * math.sin(theta2) * math.sin(phi1)
            z2 = center[2] + radius * math.cos(theta2)

            # Vertex 3
            x3 = center[0] + radius * math.sin(theta1) * math.cos(phi2)
            y3 = center[1] + radius * math.sin(theta1) * math.sin(phi2)
            z3 = center[2] + radius * math.cos(theta1)

            # Vertex 4
            x4 = center[0] + radius * math.sin(theta2) * math.cos(phi2)
            y4 = center[1] + radius * math.sin(theta2) * math.sin(phi2)
            z4 = center[2] + radius * math.cos(theta2)

            # Create two triangles for this quad
            if i > 0:  # Skip degenerate triangles at poles
                # Triangle 1: (1, 2, 3)
                v1 = (x1, y1, z1)
                v2 = (x2, y2, z2)
                v3 = (x3, y3, z3)

                # Calculate normal
                n = calculate_normal(v1, v2, v3)
                triangles.append((n, v1, v2, v3))

            if i < resolution - 1:  # Skip degenerate triangles at poles
                # Triangle 2: (2, 4, 3)
                v1 = (x2, y2, z2)
                v2 = (x4, y4, z4)
                v3 = (x3, y3, z3)

                # Calculate normal
                n = calculate_normal(v1, v2, v3)
                triangles.append((n, v1, v2, v3))

    # Write binary STL file
    write_binary_stl(filename, triangles)
    print(f"Generated sphere STL with {len(triangles)} triangles")
    print(f"Sphere: radius={radius}, center={center}")
    print(f"Bounding box: ({center[0]-radius:.1f}, {center[1]-radius:.1f}, {center[2]-radius:.1f}) to ({center[0]+radius:.1f}, {center[1]+radius:.1f}, {center[2]+radius:.1f})")

def calculate_normal(v1, v2, v3):
    """Calculate triangle normal vector."""
    # Vector from v1 to v2
    edge1 = (v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2])
    # Vector from v1 to v3
    edge2 = (v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2])

    # Cross product
    nx = edge1[1] * edge2[2] - edge1[2] * edge2[1]
    ny = edge1[2] * edge2[0] - edge1[0] * edge2[2]
    nz = edge1[0] * edge2[1] - edge1[1] * edge2[0]

    # Normalize
    length = math.sqrt(nx*nx + ny*ny + nz*nz)
    if length > 0:
        nx /= length
        ny /= length
        nz /= length

    return (nx, ny, nz)

def write_binary_stl(filename, triangles):
    """Write triangles to binary STL file."""
    with open(filename, 'wb') as f:
        # Write 80-byte header
        header = b'Binary STL generated by FluidX3D sphere generator' + b'\0' * 31
        f.write(header)

        # Write number of triangles
        f.write(struct.pack('<I', len(triangles)))

        # Write each triangle
        for normal, v1, v2, v3 in triangles:
            # Normal vector (3 floats)
            f.write(struct.pack('<fff', normal[0], normal[1], normal[2]))

            # Vertex 1 (3 floats)
            f.write(struct.pack('<fff', v1[0], v1[1], v1[2]))

            # Vertex 2 (3 floats)
            f.write(struct.pack('<fff', v2[0], v2[1], v2[2]))

            # Vertex 3 (3 floats)
            f.write(struct.pack('<fff', v3[0], v3[1], v3[2]))

            # Attribute byte count (2 bytes, usually 0)
            f.write(struct.pack('<H', 0))

def generate_box_stl(filename, size=(10, 8, 2), center=(0, 0, 0)):
    """Generate a simple box for testing."""
    triangles = []

    # Box dimensions
    dx, dy, dz = size[0]/2, size[1]/2, size[2]/2
    cx, cy, cz = center

    # Define 8 vertices of the box
    vertices = [
        (cx-dx, cy-dy, cz-dz),  # 0: bottom-left-back
        (cx+dx, cy-dy, cz-dz),  # 1: bottom-right-back
        (cx+dx, cy+dy, cz-dz),  # 2: bottom-right-front
        (cx-dx, cy+dy, cz-dz),  # 3: bottom-left-front
        (cx-dx, cy-dy, cz+dz),  # 4: top-left-back
        (cx+dx, cy-dy, cz+dz),  # 5: top-right-back
        (cx+dx, cy+dy, cz+dz),  # 6: top-right-front
        (cx-dx, cy+dy, cz+dz),  # 7: top-left-front
    ]

    # Define 12 triangles (2 per face, 6 faces)
    faces = [
        # Bottom face (z = -dz)
        (vertices[0], vertices[2], vertices[1]),
        (vertices[0], vertices[3], vertices[2]),

        # Top face (z = +dz)
        (vertices[4], vertices[5], vertices[6]),
        (vertices[4], vertices[6], vertices[7]),

        # Front face (y = +dy)
        (vertices[3], vertices[6], vertices[2]),
        (vertices[3], vertices[7], vertices[6]),

        # Back face (y = -dy)
        (vertices[0], vertices[1], vertices[5]),
        (vertices[0], vertices[5], vertices[4]),

        # Right face (x = +dx)
        (vertices[1], vertices[2], vertices[6]),
        (vertices[1], vertices[6], vertices[5]),

        # Left face (x = -dx)
        (vertices[0], vertices[4], vertices[7]),
        (vertices[0], vertices[7], vertices[3]),
    ]

    # Calculate normals and add triangles
    for v1, v2, v3 in faces:
        normal = calculate_normal(v1, v2, v3)
        triangles.append((normal, v1, v2, v3))

    # Write binary STL file
    write_binary_stl(filename, triangles)
    print(f"Generated box STL with {len(triangles)} triangles")
    print(f"Box: size={size}, center={center}")

if __name__ == "__main__":
    # Generate a sphere with radius 5, centered at origin
    generate_sphere_stl("assets/sphere.stl", radius=5.0, center=(0, 0, 0), resolution=20)

    # Also generate a simple box for testing
    generate_box_stl("assets/box.stl", size=(10, 8, 2), center=(0, 0, 0))
